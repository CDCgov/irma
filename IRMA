#!/bin/bash
PROGRAM="Influenza Read MiSeq Assembler (IRMA)"
AUTHOR="Samuel S. Shepard"
EMAIL="vfn4@cdc.gov"
AFFIL="NCIRD/OID/CDC"
DATE="09 MAR 2015"
VERSION="0.5.8"
LICENSE="GPL version 3. This program comes with ABSOLUTELY NO WARRANTY. This is free software.
You are welcome to redistribute it under certain conditions. See:  <http://www.gnu.org/licenses/>."

if [ $# -eq 4 ];then
	PAIRED=1
	MODULE=$1
	LEFT=$2			# R1 / left FASTQ
	RIGHT=$3		# R2 / right FASTQ
	RUN=$4			# name of the run
elif [ $# -eq 3 ];then
	PAIRED=0
	MODULE=$1
	SINGLE=$2		# single paired end FASTQ
	RUN=$3			# name of the run
else
	echo -e "$PROGRAM, v$VERSION ($DATE)"
	echo -e "$AUTHOR ($AFFIL), $EMAIL\n"
	echo -e "$LICENSE\n\nUSAGE:"
	echo -e "(PAIRED-END):\t$(basename $0) <MODULE> <R1.fastq.gz/R1.fastq> <R2.fastq.gz/R2.fastq> <run_name>"
	echo -e "(SINGLE-END):\t$(basename $0) <MODULE> <fastq/fastq.gz> <run_name>\n"
	exit 1
fi

# FREE VARIABLES
QUAL_THRESHOLD=30	# average or median threshold
INS_T=0.15		# threshold for insertion refinement of references
DEL_T=0.75		# threshold for deletion refinement of references
MIN_C=2			# minimum count for variants
MIN_F=0.0075		# minimum frequency for variants
MIN_FI=0.0075		# minimum frequency for insertion variations
MIN_FD=0.0075		# minimum frequency for non-singleton deletion variations
MIN_AQ=24		# minimum average variant quality, does not apply to deletions
MIN_TCC=100		# minimum non-ambiguous column coverage
MIN_CONF=0.80		# minimum confidence not machine error
MIN_AMBIG=0.25		# minimum ambiguous nucleotides for amended consensus (with ambig codes)
SIG_LEVEL=0.999		# significance test level for variant calling (.90,.95,.99,.999). 
LFASTM=1		# LABEL sort fast-mode
AUTO_F=1		# auto-adjust frequency threshold
NONSEGMENTED=0		# segmented versus non-segmented virus
MIN_RP=15		# minimum read pattern count
MIN_RC=15		# minimum read count
SKIP_E=1		# skip reference elongation
INCL_CHIM=0		# whether or not to get rid of chimera

# ALTER AT RISK
GRID_ON=1		# enable cluster/grid computation
SSW_M=1			# smith-waterman match score
SSW_X=5			# smith-waterman mismatch penalty
SSW_O=10		# smith-waterman gap open penalty
SSW_E=1			# smith-waterman gap extension penalty
MIN_LEN=150		# minimum read length for QUALITY reads
MAX_ROUNDS=2		# maximum number of iterations to BLAT
R=1			# current round
LANG=POSIX		# collation
MAX_ITER_ASSEM=5	# maximum number of polish assembly iterations to perform, 3 should be sufficient with 4 to prove
MATCH_PROC=80		# maximum processes for the MATCH
ALIGN_PROC=25		# maximum processes for the rough align
ASSEMBLE_PROC=25	# maximum processes for assembly
SINGLE_LOCAL_PROC=8	# maximum processes for QC on local node
DOUBLE_LOCAL_PROC=4	# maximum processes for the left or right pairs
MATCH_LIMIT=60000	# threshold before grid
ALIGN_LIMIT=500		# threshold before grid
SORT_LIMIT=1000		# threshold before grid
ASSEM_LIMIT=80000	# threshold before grid

# DO NOT ALTER
owd=$(pwd)
bpath=
if [ "$bpath" == "" ]; then
	bpath=$( cd -P "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
fi
rpath=$bpath/IRMA_RES	# IRMA resources
spath=$rpath/scripts	# IRMA specific scripts/binaries
LABEL=$(which LABEL)
Lspath=$(dirname $LABEL)/LABEL_RES/scripts
Lmpath=$(dirname $LABEL)/LABEL_RES/training_data/IRMA
PARALLEL="$spath/parallel --will-cite"
PARSE_SORT_OPTS=""


if [ ! -d $rpath/ppath/$RUN ]; then
	mkdir $rpath/ppath/$RUN
else
	echo "$(basename $0) ERROR: run '$RUN' exists, operations have been ABORTED!"
	exit 1
fi
ppath=$rpath/ppath/$RUN


MODULE2=$(echo $MODULE|cut -f1 -d'-')
if [ ! -d $rpath/modules/$MODULE2 ];then
	time_stamp "Error: $MODULE2 not found."
	exit 1
else
	mpath=$rpath/modules/$MODULE2	
fi

# STAGES
MATCH_PROG="BLAT"
SORT_PROG="LABEL"
ALIGN_PROG="SAM"
ASSEM_PROG="SSW"

# stage paths
matchp=$ppath/MATCH
sortp=$ppath/SORT
alignp=$ppath/ALIGN
assemp=$ppath/ASSEMBLY
refp=$ppath/GENES
mkdir $matchp $sortp $alignp $assemp $refp

# initial BLAT database
REF_SET=$mpath/blatDB.fasta
source $mpath/params-$MODULE.sh

if [ "$AUTO_F" -eq 1 ];then
	AUTO_F="-A"
else
	AUTO_F=""
fi

# Enforce LABEL specific options
[ "$SORT_PROG" != "LABEL" ] && LFASTM=0

# BLAT PARSE options
[ "$LFASTM" -eq "1" ] && BLAT_PARSE_OPTS="-T"
[ "$SORT_PROG" == "BLAT" ] && BLAT_PARSE_OPTS="-C"
[ "$ALIGN_PROG" == "BLAT" ] && BLAT_PARSE_OPTS="-C -A"
[ "$INCL_CHIM" -eq "1" ] && BLAT_PARSE_OPTS="$BLAT_PARSE_OPTS -I"
[ "$SKIP_E" -eq "1" ] && BLAT_PARSE_OPTS="$BLAT_PARSE_OPTS -S"


# ALIGN editing options
COMBINE_ALIGN_OPTS=""
[ "$ALIGN_PROG" == "BLAT" ] && COMBINE_ALIGN_OPTS="-A"
[ "$SKIP_E" -eq "1" ] && COMBINE_ALIGN_OPTS="$COMBINE_ALIGN_OPTS -S"

# SSW options
SSW_OPTS="-x $SSW_X -m $SSW_M -o $SSW_O -e $SSW_E"

# BLAT options
BLAT_OPTS="-oneOff=1 -minIdentity=80 -tileSize=10"

# Reference elongation
if [ "$SKIP_E" -eq 1 ];then
	SKIP_E="-S"
else
	SKIP_E=""
fi

#### FUNCTIONS ####

# FNC - ERROR TEST #
# Idea courtesy: steve-parker.org/sh/exitcodes.shtml
function err_test() {
	if [ "$1" -ne "0" ];then
		echo ""
		if [ $# -eq "1" ]; then 
			echo "$(basename $0) ERROR: operations have been ABORTED!"
		else
			echo "$(basename $0) ERROR ($2): operations have been ABORTED!"
		fi
		exit 1
	fi
}

function time_stamp() {
	local t=$(date +"%Y-%m-%d %k:%M:%S")
	echo -e "[$t]\tIRMA/$MODULE $1"
}


#####################
### Main Functions ###

function moveProject() {
	local x=2
	local mvpath=$owd/$RUN
	
	if [ ! -d $mvpath ];then
		mv $ppath $mvpath
	else
		local outpath=${mvpath}-V$x
		while [ -d $outpath ];do
			x=$(expr $x + 1)
			outpath=${mvpath}-V$x
		done
		mv $ppath $outpath
	fi
}

function preProcess() {
	local file=$1
	local name=$2
	local numGroups=$3

	# SEPARATE
	if [ ${file: -3} == ".gz" ];then 
		$Lspath/interleavedSamples.pl -Z -G $numGroups -Q $file $ppath/$name > /dev/null
	else
		$Lspath/interleavedSamples.pl -G $numGroups -Q $file $ppath/$name > /dev/null
	fi

	# FILTER
	for i in $ppath/${name}*.fastq;do
		local prefix=$(basename $i .fastq)
		$spath/fastQ_converter.pl -Q -M -T $QUAL_THRESHOLD -L $MIN_LEN $i > $ppath/$prefix.QC.fastq &
	done
	wait

	# COLLATE
	$spath/xflate.pl -C -Q -L $name $ppath/$name.xfl $ppath/${name}*.QC.fastq > $ppath/$name.fa
}

function doBLAT() {
	local refDB=$1
	local queryDB=$2
	local prefix=$3
	local name=$4
	local workdir=$5
	local procs=$6
	local doGrid=$7
	local script=$workdir/${prefix}-${name}-BLAT

###
cat >$script.sh  <<EOL
#!/bin/bash
LANG=$LANG
shopt -u nocaseglob;shopt -u nocasematch

if [ "\$#" -eq "1" ];then
	ID=\$(printf %04d \$1)
else
	ID=\$(printf %04d \$SGE_TASK_ID)
fi
INPUT=$workdir/${prefix}-${name}_\$ID.fasta
OUTPUT=$workdir/${prefix}-${name}_\$ID.blat

$spath/blat $refDB \$INPUT \$OUTPUT $BLAT_OPTS
$spath/parseBlat.pl \$OUTPUT \$INPUT $BLAT_PARSE_OPTS -P $prefix
EOL
###
	$Lspath/interleavedSamples.pl -G $procs $queryDB $workdir/$prefix-$name > /dev/null 2>&1
	if [ "$doGrid" -eq "1" ];then
		qsub -t 1-$procs:1 -N ${prefix}-${name}-BLAT -sync y -wd $workdir -j y -o $script.o $script.sh > /dev/null 2>&1
		rm $script.{o,sh}
	else 
		chmod 755 $script.sh
		$PARALLEL --workdir $workdir -j $SINGLE_LOCAL_PROC $script.sh {} ::: $(seq $procs) > /dev/null 2>&1
		rm $script.sh
	fi
}


function doMATCH() {
	local DB=$1
	local prefix=$2
	local n=$3
	local match_ext=""
	local name="all"
	local doGrid=0
	local procs=0
	local i=0

	if [ $n -gt $MATCH_LIMIT -a $GRID_ON -eq "1" ];then
		doGrid=1
		procs=$MATCH_PROC
	else
		doGrid=0
		if [ "$n" -lt "$SINGLE_LOCAL_PROC" ];then
			procs=1
		else
			procs=$SINGLE_LOCAL_PROC
		fi
	fi

	if [ "$MATCH_PROG" == "BLAT" ];then
		doBLAT $REF_SET $DB $prefix $name $matchp $procs $doGrid
		match_ext="blat"
	else
		time_stamp "$prefix aborted, MATCH:$MATCH_PROG not implemented"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi

	time_stamp "$prefix performed all match with $MATCH_PROG & parsed"
	# consolidate
	cat $matchp/${prefix}-${name}_????.match > $matchp/${prefix}.match &
	cat $matchp/${prefix}-${name}_????.nomatch > $matchp/${prefix}.nomatch &
	cat $matchp/${prefix}-${name}_????.chim > $matchp/${prefix}.chim &
	wait

	# LABEL fast mode consoldiation
	if [ $LFASTM -eq "1" -a $SORT_PROG == "LABEL" ];then
		cat $matchp/${prefix}-${name}_????.match.HA > $matchp/${prefix}.match.HA 2> /dev/null &
		cat $matchp/${prefix}-${name}_????.match.NA > $matchp/${prefix}.match.NA 2> /dev/null &
		cat $matchp/${prefix}-${name}_????.match.OG > $matchp/${prefix}.match.OG 2> /dev/null &
		wait
		rm $matchp/${prefix}-${name}_????.match.{HA,NA,OG}
	fi

	# CLEAN UP	
	rm $matchp/${prefix}-${name}_????.{match,nomatch,chim,fasta}
	cd $matchp
	tar  -czf $matchp/${prefix}.tar.gz ${prefix}-${name}_????.$match_ext 2> /dev/null
	cd - > /dev/null
	rm $matchp/${prefix}-${name}_????.$match_ext
	time_stamp "$prefix consolidated & cleaned"

	# EXTEND to SORT
	if [ "$SORT_PROG" == "$MATCH_PROG" ];then
		mkdir $ppath/SORT/${prefix}
		cat $matchp/${prefix}-${name}_????.class > $matchp/${prefix}.class
		rm $matchp/${prefix}-${name}_????.class
		mv $matchp/${prefix}.class $ppath/SORT/$prefix/SORT_result.txt
	fi

	# EXTEND to ALIGN
	if [ "$ALIGN_PROG" == "$MATCH_PROG" ];then
		mv $matchp/*.sto $alignp
	fi
}

function doSORTgrid() {
	local DB=$1
	local prefix=$2

	if [ "$SORT_PROG" == "LABEL" ];then
		if [ $# -eq "3" ];then
			local Earg=$3
		else
			local Earg=2
		fi

		if [ $LFASTM -eq "1" ];then
			mkdir $sortp/${prefix}
			local groupFile=""
			local geneGroup=""

			for groupFile in $matchp/${prefix}.match.*;do
				x=$(wc -l < $groupFile)
				geneGroup=$(basename $groupFile|cut -f3 -d'.')

				if [ $x -gt 0 ];then
					$LABEL -E $Earg -W $sortp/${prefix} $groupFile $geneGroup irma$geneGroup > /dev/null 2>&1 &
				fi
			done
			wait

			for i in $sortp/${prefix}/*;do 
				i=$(basename $i)
				mv $sortp/${prefix}/${i}/LEVEL_trace.tab $sortp/${prefix}/${i}_LEVEL_trace.tab
			done
			cat $sortp/${prefix}/*/LEVEL_result.tab > $sortp/${prefix}/SORT_result.txt
		else
			# SORT using LABEL full
			$LABEL -E $Earg -W $sortp $matchp/${prefix}.match $prefix IRMA > /dev/null 2>&1
			mv $sortp/${prefix}/LEVEL_result.tab > $sortp/${prefix}/SORT_result.txt
		fi
	elif [ "$SORT_PROG" == "BLAT" ];then
		# TO-DO: assumes BLAT was run on MATCH	
		:
	fi
}

function doSORTlocal() {
	local DB=$1
	local prefix=$2
	
	if [ "$SORT_PROG" == "LABEL" ];then
		doSORTgrid $DB $prefix 0
	elif [ "$SORT_PROG" == "BLAT" ];then
		# TO-DO: assumes BLAT was run on MATCH	
		:
	fi
}

function doSORT() {
	local DB=$1
	local prefix=$2
	local n=$3

	if [ "$SORT_PROG" != "LABEL" -a "$SORT_PROG" != "BLAT" ];then
		time_stamp "$prefix aborted, SORT:$SORT_PROG not implemented"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi

	if [ $n -gt $SORT_LIMIT -a "$GRID_ON" -eq "1" ];then
		doSORTgrid $DB $prefix
	else
		doSORTlocal $DB $prefix
	fi
	time_stamp "$prefix sorted using $SORT_PROG"

	if [ ! -r $sortp/$prefix/SORT_result.txt ];then
		time_stamp "$prefix aborted, sort failed"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi

	x=$(grep UNRECOGNIZABLE $sortp/$prefix/SORT_result.txt -c)
	y=$(wc -l < $sortp/$prefix/SORT_result.txt)
	if [ $x -gt 0 -a $x -eq $y ];then
		time_stamp "$prefix found no significant reads"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi

	$spath/parseSORTresults.pl $sortp/$prefix/SORT_result.txt $matchp/$prefix.match $sortp/$prefix $PARSE_SORT_OPTS -C $MIN_RC -D $MIN_RP

	# CLEAN UP
	cd $sortp/$prefix
	tar  -cf - SORT_result.txt |gzip -4 - > $sortp/$prefix.tar.gz
	#tar  -cf - *LEVEL_trace.tab SORT_result.tab |gzip -4 - > $sortp/$prefix.tar.gz
	cd - > /dev/null
	rm -rf $sortp/$prefix &

}

function doSAM() {
	local queryDB=$1
	local prefix=$2
	local name=$3
	local workdir=$4
	local procs=$5
	local doGrid=$6
	local mod=$Lmpath/${name}_hmm.mod
	local script=$workdir/$prefix-$name-SAM.sh
			

cat >$script.sh  <<EOL
#!/bin/bash
LANG=$LANG
shopt -u nocaseglob;shopt -u nocasematch

if [ "\$#" -eq "1" ];then
	ID=\$(printf %04d \$1)
else
	ID=\$(printf %04d \$SGE_TASK_ID)
fi
DB=$workdir/${prefix}-${name}_\$ID.fasta
RUN=$workdir/${prefix}-${name}_\$ID
MOD=$mod

$Lspath/align2model \$RUN -modelfile \$MOD -db \$DB
$spath/a2mToMatchStats.pl \$RUN.a2m \$RUN.sto $SKIP_E
EOL

	$Lspath/interleavedSamples.pl $queryDB $workdir/$prefix-$name -G $procs > /dev/null
	if [ "$doGrid" -eq "1" ];then
		qsub -t 1-$procs:1 -N $prefix-$name-SAM -sync y -wd $workdir -j y -o $script.o $script.sh > /dev/null 2>&1
		rm $script.{o,sh}
	else
		chmod 755 $script.sh
		$PARALLEL --workdir $workdir -j $SINGLE_LOCAL_PROC $script.sh {} ::: $(seq $procs) > /dev/null 2>&1
		rm $script.sh
	fi
	rm $workdir/${prefix}-${name}_????.{fasta,a2m}
}

function doALIGN() {
	local prefix=$1
	local doGrid=0
	local procs=0
	local queryDB=""
	local i=0
	local j=0
	local name=""
	local gene=""

	# FOR EACH GENE
	for queryDB in $sortp/$prefix-*.fa;do
		n=$(grep '>' $queryDB -c)
		name=$(basename $queryDB .fa);name=${name#*-}
		if [ $n -gt $ALIGN_LIMIT -a "$GRID_ON" -eq "1" ];then
			doGrid=1
			procs=$ALIGN_PROC
		else
			doGrid=0
			if [ "$n" -lt "$SINGLE_LOCAL_PROC" ];then
				procs=1
			else	
				procs=$SINGLE_LOCAL_PROC	
			fi
		fi

		if [ "$ALIGN_PROG" == "SAM" ];then
			doSAM $queryDB $prefix $name $alignp $procs $doGrid &
		elif [ "$ALIGN_PROG" == "BLAT" ];then
			j=$(expr $R - 1)
			if [ "$R" -gt 1 ];then
				for i in $(seq $j);do
					rm $alignp/R${j}-$name*.sto
					doBLAT $refp/R${j}-$name.ref $sortp/R${i}-${name}.fa R$i $name $alignp $procs $doGrid &
				done
			fi
		else
			time_stamp "$prefix aborted, ALIGN:$ALIGN_PROG not implemented"
			if [ $R -gt 1 ];then
				doPostProcessing
			fi
			moveProject
			time_stamp 'finished!'
			exit
		fi
	done
	wait
	time_stamp "$prefix rough aligned reads using $ALIGN_PROG"

	# CREATE NEW REFERENCES
	for i in $sortp/$prefix-*.fa;do
		name=$(basename $i .fa)
		gene=${name#*-}
		
		$spath/combineALIGNstats.pl $COMBINE_ALIGN_OPTS -N $gene $alignp/R*-${gene}_????.sto > $refp/$name.ref &
		# consider placing burden on the function itself to do the cleanup
		[ "$ALIGN_PROG" == "BLAT" -a "$R" -gt 1 ] && rm $alignp/R*-${gene}_????.{match,nomatch,chim,fasta,class,blat} &
	done
	wait
}

function doRound() {
	local DB=$1
	local prefix=$2
	local n=$(grep '>' $DB -c)
	local Earg=2	
	local x=0
	local y=0
	local gene=""
	local name=""

	# make sure directories are available
	[ ! -d $ppath/MATCH ] && mkdir $ppath/MATCH
	[ ! -d $ppath/SORT ] && mkdir $ppath/SORT
	[ ! -d $ppath/ALIGN ] && mkdir $ppath/ALIGN
	[ ! -d $ppath/GENES ] && mkdir $ppath/GENES

	# MATCH stage
	doMATCH $DB $prefix $n	
	n=$(grep '>' $matchp/${prefix}.match -c)
	if [ "$n" -eq "0" ];then
		time_stamp "$prefix aborted, no matches found"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi
	
	### SORT stage ###
	DB=$matchp/${prefix}.match
	doSORT $DB $prefix $n

	# PRIMARY vs SECONDARY tests
	# if we have primary data from the current round
	if test -n "$(shopt -s nullglob;echo $sortp/$prefix-*.fa)";then
		# for each current primary dataset
		for i in $sortp/$prefix-*.fa;do
			name=$(basename $i .fa)
			gene=${name#*-}
			# if previously a secondary lineage, make the current primary a secondary
			test -n "$(shopt -s nullglob;echo $sortp/R*-${gene}.fa.2)" && mv $i ${i}.2
		done
	fi

	# vice-versa, if we have secondary data from this round
	if test -n "$(shopt -s nullglob;echo $sortp/$prefix-*.fa.2)";then
		# for each current secondary dataset
		for i in $sortp/$prefix-*.fa.2;do
			name=$(basename $i .fa.2)
			gene=${name#*-}
			# if previously a primary lineage, make the current secondary a primary
			# used to be ".ref"
			test -n "$(shopt -s nullglob;echo $sortp/R*-${gene}.fa)" && mv $i $sortp/$(basename $i .2)
		done
	fi

	### ALIGN stage ###
	# given we have primary data in this around	
	if test -n "$(shopt -s nullglob;echo $sortp/$prefix-*.fa)";then
		doALIGN $prefix
	else
		time_stamp "$prefix aborted, found fewer than $MIN_RP RPs or $MIN_RC reads for all template"
		if [ $R -gt 1 ];then
			doPostProcessing
		else
			mkdir $ppath/low_abundance
			mkdir $ppath/other_data
			for i in $sortp/*2;do
				mv $i $ppath/low_abundance/$(basename $i .2)
			done
			mv $ppath/low_abundance/*UNRECOGNIZABLE* $ppath/other_data/failed_sort.fa

			mv $ppath/R1.nomatch $ppath/other_data/unmatched_data.fa
			mv $ppath/R1.chim $ppath/other_data/chimeric.fa
			mv $matchp/R1.tar.gz $ppath/other_data/match_output.tar.gz
			mv $sortp/R1.tar.gz $ppath/other_data/sort_output.tar.gz
			echo -e "Gene\tRead Patterns\tRead Count" > $ppath/sorted_read_stats.txt
			cat $sortp/R1.txt >> $ppath/sorted_read_stats.txt && rm $sortp/R1.txt
			echo -e "Interleaved sample\tStarting reads\tQC'd reads\tQuality threshold\tMin length\tUse median" > $ppath/read_QC_filtering.txt
			cat $ppath/QC_log.txt >> $ppath/read_QC_filtering.txt && rm $ppath/QC_log.txt
			rm $ppath/R*.{match,fa,xfl}
			[ $LFASTM -eq "1" ] && rm $ppath/R1.match.*
			rmdir $alignp $matchp $refp $sortp
		fi
	
		moveProject
		time_stamp 'finished!'
		exit
	fi

	cat $refp/${prefix}*.ref > $refp/${prefix}.refs
	REF_SET=$refp/${prefix}.refs
	QUERY_SET=$matchp/$prefix.nomatch
	time_stamp "$prefix references created"
}

#############################################
############# ASSEMBLY SECTION ##############
#############################################

#-------------------------------------------#
#--- Polishing assembly function -----------#
#-------------------------------------------#
function ASSEM_RUN_SSW() {
	local iter=$1
	local gene=$2
	local ref=$3
	local procs=$4
	local doGrid=$5
	local script=$assemp/F${iter}-${gene}

###
cat > $script.sh  <<EOL
#!/bin/bash
LANG=$LANG
shopt -u nocaseglob;shopt -u nocasematch

if [ "\$#" -eq "1" ];then
	ID=\$(printf %04d \$1)
else
	ID=\$(printf %04d \$SGE_TASK_ID)
fi
FASTQ=$assemp/${gene}_\$ID.fastq
SAM=$assemp/F${iter}-${gene}-\$ID.sam
STAT=$assemp/F${iter}-${gene}-\$ID.sto

$spath/ssw -s -c -h -r $SSW_OPTS $ref \$FASTQ > \$SAM 2> /dev/null
$spath/samStats.pl $ref \$SAM \$STAT
EOL
###

	# ASSEMBLE on grid vs local
	if [ "$doGrid" -eq "1" ];then
		qsub -t 1-$ASSEMBLE_PROC:1 -N F${iter}-$gene -sync y -wd $assemp -j y -o $script.o $script.sh > /dev/null 2>&1
	else
		chmod 755 $script.sh
		$PARALLEL --workdir $ppath -j $SINGLE_LOCAL_PROC $script.sh {} ::: $(seq $procs)
	fi
	$spath/catSAMfiles.pl $assemp/F${iter}-${gene}-*.sam > $assemp/F${iter}-$gene.sam
	rm $script.sh
}


#-------------------------------------------#
#--- Scoring assembly function   -----------#
#-------------------------------------------#
function ASSEM_SCORE_SSW() {
	local SAM=$1
	echo -n $(cut -f12 $SAM|$spath/sumField.pl -F 3 -D ':')
}
#############################################
#############################################
#############################################


function doCALLS() {
	local iter=$1
	local gene=$2
	local final=$3
	local procs=$4
	local doGrid=$5
	local ref=$assemp/F${iter}-${gene}.ref

	# PAIRED VS SINGLE END
	if [ "$PAIRED" -eq "1" ];then
		local prefix=M${iter}-${gene}
		local prefix2=$assemp/M${iter}-${gene}
		local pstats="-E $final-pairingStats.txt"
	else
		local prefix=S${iter}-${gene}
		local prefix2=$assemp/F${iter}-${gene}
		local pstats=""
	fi

#########################################
# DO CALL STATS and MERGE if PAIRED END #
#########################################
cat > $assemp/${prefix}.sh <<EOL
#!/bin/bash
LANG=$LANG
shopt -u nocaseglob;shopt -u nocasematch

if [ "\$#" -eq "1" ];then
	ID=\$(printf %04d \$1)
else
	ID=\$(printf %04d \$SGE_TASK_ID)
fi
SAM=$assemp/F${iter}-${gene}-\$ID.sam
VPREFIX=$assemp/V${iter}-${gene}-\$ID

if [ "$PAIRED" -eq "1" ];then
	MSAM=$assemp/M${iter}-${gene}-\$ID.sam
	MPREFIX=$assemp/M${iter}-${gene}-\$ID
	$spath/mergeSAMpairs.pl -S $ref \$SAM \$MPREFIX
	$spath/varCallStats.pl $ref \$MSAM \$VPREFIX
else
	$spath/varCallStats.pl $ref \$SAM \$VPREFIX
fi

EOL
#########################################

	# GRID vs LOCAL execution of the CALL STATS step, inherits from ASSEMBLY step currently
	if [ "$doGrid" -eq "1" ];then
		qsub -t 1-$ASSEMBLE_PROC:1 -N $prefix -sync y -wd $assemp -j y -o $assemp/${prefix}.o $assemp/${prefix}.sh > /dev/null 2>&1
	else
		chmod 755 $assemp/${prefix}.sh
		$PARALLEL --workdir $ppath -j $SINGLE_LOCAL_PROC $assemp/${prefix}.sh {} ::: $(seq $procs)
	fi

	# GROUP
	$spath/catSAMfiles.pl ${prefix2}-*.sam > ${final}.sam

	# DO the CALL step
	local callPhaseArgs="-C $MIN_C -F $MIN_F -I $MIN_FI -D $MIN_FD -Q $MIN_AQ -T $MIN_TCC -M $MIN_CONF -S $SIG_LEVEL $AUTO_F"
	[ "$PAIRED" -eq "1" ] && $spath/getPairingStats.pl ${prefix2}-*.sto > $final-pairingStats.txt
	$spath/callPhase.pl -P -G $callPhaseArgs $pstats $ref $final $assemp/V${iter}-${gene}-*.sto
}

function REFINE_ASSEMBLY_CALL_PHASE() {
	local gene=$1
	local procs=$2
	local doGrid=$3
	local final=$4
	
	if [ "$ASSEM_PROG" == "SSW" ];then
		local ASSEM_FUNCTION="ASSEM_RUN_SSW"
		local ASSEM_SCORE="ASSEM_SCORE_SSW"
	else
		time_stamp "at $gene aborted, ASSEMBLE:$ASSEM_PROG not implemented"
		if [ $R -gt 1 ];then
			doPostProcessing
		fi
		moveProject
		time_stamp 'finished!'
		exit
	fi

	local iter=1
	local log=$assemp/$gene.log
	local lastRef=""
	local lastSAM=""
	local currRef=$assemp/F${iter}-$gene.ref
	local currSAM=$assemp/F${iter}-$gene.sam
	local theBAM=""

	$ASSEM_FUNCTION $iter $gene $currRef $procs $doGrid
	local lastScore=0
	local currScore=$($ASSEM_SCORE $currSAM)
		echo -e "$currScore\t$currSAM" >> $log
		while [ $lastScore -lt $currScore ];do
			lastRef=$currRef
			lastSAM=$currSAM
			lastSTO=$assemp/F${iter}-$gene-*.sto
			lastScore=$currScore
			theBAM=$assemp/F${iter}-$gene.bam
			$spath/samtools view -bS $currSAM > $theBAM 2> /dev/null
			iter=$(expr $iter + 1)
			currRef=$assemp/F${iter}-$gene.ref
			currSAM=$assemp/F${iter}-$gene.sam

			# Generate current scaffold from previous SAM and reference, assemble & compare
			$spath/combineSAMstats.pl $lastRef -N $gene -I $INS_T -D $DEL_T $lastSTO > $currRef
			$ASSEM_FUNCTION $iter $gene $currRef $procs $doGrid 
			currScore=$($ASSEM_SCORE $currSAM)
			echo -e "$currScore\t$currSAM" >> $log
			rm $lastSTO
			[ $iter -eq $MAX_ITER_ASSEM ] && break
		done
		
#		if [ $lastScore -eq $currScore ];then
#			mv $currRef $lastRef
#			mv $currSAM $lastSAM
#		else 		
#			rm $currRef
#			iter=$(expr $iter - 1)
#		fi

		if [ $lastScore -gt $currScore ];then
			rm $currRef $currSAM
			# move back a tick
			iter=$(expr $iter - 1)
			
		fi

		# CALL variants
		doCALLS $iter $gene $final $procs $doGrid

		# CLEAN UP
		rm $assemp/${gene}_????.fastq
		rm $assemp/*-${gene}-????.*
		rm $assemp/*-${gene}.sh
}

function ASSEMBLE_REPORT() {
	local gene=$1
	local final=$ppath/$gene
	local fastq=$assemp/$gene.fastq
	local size=$(expr $(wc -l < $fastq) / 4)
	local doGrid=0
	local procs=0

	# SCOPE
	if [ $size -gt $ASSEM_LIMIT -a "$GRID_ON" -eq "1" ];then
		procs=$ASSEMBLE_PROC
		doGrid=1
	else
		doGrid=0
		if [ $size -gt $SINGLE_LOCAL_PROC ];then
			procs=$SINGLE_LOCAL_PROC
		else
			procs=1
		fi
	fi

	# ITERATIVE REFINEMENT of ASSEMBLY chained to CALLING and PHASING
	$Lspath/interleavedSamples.pl -G $procs -P $fastq $assemp/$gene > /dev/null
#	if [ "$doGrid" -eq "0" ];then
#		$PARALLEL --semaphore --semaphorename IRMA -j1 REFINE_ASSEMBLY_CALL_PHASE $gene $procs $doGrid $final
#		$PARALLEL --semaphore --semaphorename IRMA --wait
#	else
		REFINE_ASSEMBLY_CALL_PHASE $gene $procs $doGrid $final
#	fi
	
	local n=$(wc -l < ${final}-variants.txt)
	if [ $n -gt 2 ]; then
		$PARALLEL $spath/sqmHeatmap.R ${final}-{}.sqm ${final}-{}.pdf 2 ::: EXPENRD JACCARD MUTUALD > /dev/null
	fi

	if [ $n -gt 1 ]; then
		$spath/coverageDiagram.R $final-coverage.txt $final-variants.txt $final-pairingStats.txt $final-coverageDiagram.pdf > /dev/null 2>&1
	else
		$spath/simpleCoverageDiagram.R $final-coverage.txt $final-coverageDiagram.pdf > /dev/null 2>&1
	fi
	$spath/heuristicDiagram.R ${final}-allAlleles.txt ${final}-heuristics.pdf > /dev/null 2>&1
	$spath/amendConsensus.pl -C $MIN_C -N $RUN -S -F $MIN_AMBIG ${final}.fasta ${final}-variants.txt -P $ppath
	if [ -r ${final}-insertions.txt -a -r ${final}-deletions.txt ];then
		$spath/vcfGenerator.pl $callPhaseArgs ${final}.fasta ${final}-allAlleles.txt ${final}-insertions.txt ${final}-deletions.txt > ${final}.vcf
	fi

	$spath/samtools view -bS ${final}.sam > ${final}.bam 2> /dev/null
	$spath/samtools sort ${final}.bam $final > /dev/null 2>&1
	$spath/samtools index ${final}.bam > /dev/null 2>&1
	rm $assemp/F*-$gene.sam
	time_stamp "finished $gene"
}



function doPHASEgrid() {
	echo Possible
}

function doPHASElocal() {
	echo Possible
}


function doPostProcessing() {
	# INFLATE TO FASTQ
	for name in $($spath/finalRefs.pl $refp/*.refs);do
		gene=${name#*-}
		cat $sortp/R*-$gene.fa > $assemp/$gene.fa
		$spath/xflate.pl -I -Q -R $ppath/R0.xfl $assemp/$gene.fa > $assemp/$gene.fastq &
		ln $refp/$name.ref $assemp/F1-$gene.ref
	done
	time_stamp 'converted back to fastq'

	# SAVE unmatched read patterns
	cd $matchp
	tar -cf - R$(($R<=MAX_ROUNDS?$R:$MAX_ROUNDS)).nomatch|gzip -4 - > $ppath/unmatched_read_patterns.tar.gz &
	cd - > /dev/null
	cd $alignp
	tar -cf - R*.sto|gzip -4 - > $alignp/storedCounts.tar.gz &
	cd - > /dev/null
	wait
	time_stamp 'saved unmatched read patterns'

	# CLEAN UP
	[ $LFASTM -eq "1" ] && rm $matchp/R?.match.{HA,NA,OG}
	grep '>' $matchp/R?.{match,nomatch,chim} $ppath/R0.fa -c > $ppath/NR_COUNTS_log.txt
	rm $ppath/R0.{fa,xfl} &
	rm $alignp/R*.sto &
	rm $refp/R*.refs &
	rm $matchp/R*.{match,nomatch,chim} &
	rm $sortp/R*.fa &
	wait
	
	# POLISH the final assembly & do variant calls/phasing
	for ref1 in $assemp/F1-*.ref;do
		name=$(basename $ref1 .ref)
		gene=${name#*-}
		ASSEMBLE_REPORT $gene &
	done
	wait
	time_stamp 'mapped to references, BAM files created'

	cd $assemp
	tar -cf - *.fastq|gzip -4 - > $assemp/reads.tar.gz
	cd - > /dev/null
	grep '>' $assemp/*.fa -Hc >> $ppath/NR_COUNTS_log.txt
	rm $assemp/*.fastq $assemp/*.fa

	for i in $ppath/*bam;do 
		echo ${i}:$(samtools view -c $i) >> $ppath/READ_log.txt
	done
	
	local readSize=$(expr $(zcat $ppath/ASSEMBLY/reads.tar.gz |wc -l) / 4)
	$spath/percentages.R $ppath/QC_log.txt $readSize $ppath/NR_COUNTS_log.txt $ppath/READ_log.txt $ppath/READ_PERCENTAGES.pdf $PAIRED > /dev/null 2>&1

	[ ! -d $ppath/amended_consensus ] && mkdir $ppath/amended_consensus
	[ -n "$(shopt -s nullglob;echo $ppath/*.fa)" ] && mv $ppath/*.fa $ppath/amended_consensus
	
	[ ! -d $ppath/matrices ] && mkdir $ppath/matrices	
	[ -n "$(shopt -s nullglob;echo $ppath/*.sqm)" ] && mv $ppath/*.sqm $ppath/matrices


	[ ! -d $ppath/figures ] && mkdir $ppath/figures
	[ -n "$(shopt -s nullglob;echo $ppath/*.pdf)" ] && mv $ppath/*.pdf $ppath/figures
	
	echo -e "Total Score\tAlignment" > $ppath/ASSEMBLY_log.txt
	cat $assemp/*.log >> $ppath/ASSEMBLY_log.txt
	rm $assemp/*.log $ppath/*.sam

	mkdir $ppath/logs
	mv $ppath/*log.txt $ppath/logs

	[ ! -d $ppath/tables ] && mkdir $ppath/tables
	[ -n "$(shopt -s nullglob;echo $ppath/*.txt)" ] && mv $ppath/*.txt $ppath/tables

	# final order
	mkdir $ppath/secondary
	mv $ppath/unmatched_read_patterns* $ppath/secondary

	# deposit secondary data
	if test -n "$(shopt -s nullglob;echo $sortp/*.fa.2)";then
		for i in $sortp/*.fa.2;do
			mv $i $ppath/secondary/$(basename $i .2)
		done
	fi

	mkdir $ppath/intermediate
	mv $refp $ppath/intermediate/0-ITERATIVE-REFERENCES
	mv $matchp $ppath/intermediate/1-MATCH_$MATCH_PROG
	mv $sortp $ppath/intermediate/2-SORT_$SORT_PROG
	mv $alignp $ppath/intermediate/3-ALIGN_$ALIGN_PROG
	mv $assemp $ppath/intermediate/4-ASSEMBLE_$ASSEM_PROG

}

####################
time_stamp "started run '$RUN'"
if [ "$PAIRED" -eq "1" ];then
	preProcess $LEFT 'LEFT' $DOUBLE_LOCAL_PROC &
	preProcess $RIGHT 'RIGHT' $DOUBLE_LOCAL_PROC &
	wait
	time_stamp 'pre-processed'

	cat $ppath/LEFT.xfl >> $ppath/RIGHT.xfl &
	cat $ppath/LEFT.fa >> $ppath/RIGHT.fa & 
	wait
	time_stamp 'consolidated'

	rm $ppath/LEFT.xfl $ppath/LEFT.fa
	mv $ppath/RIGHT.xfl $ppath/R0.xfl
	mv $ppath/RIGHT.fa $ppath/R0.fa
	cat $ppath/{LEFT,RIGHT}*.log > $ppath/QC_log.txt
	rm $ppath/{LEFT,RIGHT}*
else
	preProcess $SINGLE 'SINGLE' $SINGLE_LOCAL_PROC
	time_stamp 'pre-processed'

	mv $ppath/SINGLE.xfl $ppath/R0.xfl
	mv $ppath/SINGLE.fa $ppath/R0.fa
	cat $ppath/SINGLE*.log > $ppath/QC_log.txt
	rm $ppath/SINGLE*
fi

if [ ! -s $ppath/R0.fa ];then
	time_stamp "found no QC'd data, review QC_log.txt"
	moveProject
	time_stamp 'finished!'
	exit
fi

QUERY_SET=$ppath/R0.fa
while [ $R -le $MAX_ROUNDS ];do
	time_stamp "R$R started"
	doRound $QUERY_SET R$R
	MIN_RC=1
	MIN_RP=1

	if [ -s $QUERY_SET ];then
		R=$(expr $R + 1)
	else
		break
	fi
done
doPostProcessing
moveProject
time_stamp 'finished!'
#####################
